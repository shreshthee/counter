<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Chanting Counter — PWA + Haptics</title>

  <link rel="manifest" href="./manifest.json"/>
  <link rel="icon" href="./icons/icon-192.png" sizes="192x192" type="image/png"/>
  <meta name="theme-color" content="#0b0b0d"/>
  <meta name="apple-mobile-web-app-capable" content="yes"/>

  <style>
    /* ==========================
       Variables (Morning / Night)
       ========================== */
    :root{
      --bg: #F8FAFC;
      --card: #ffffff;
      --text: #0B1E2E;
      --main-counter: #4EB1FF;
      --accent: #FFC45A;
      --subtext: #A7FF7A;
      --tap-bg: linear-gradient(180deg, rgba(255,255,255,0.62), rgba(255,79,161,0.04));
      --om-start: #ffd6e8;
      --om-end:   #ff8bb3;
      --om-text:  #111111;
      --tap-text: #111111;
      --card-shadow: 0 12px 36px rgba(15,20,30,0.04);
    }

    /* night overrides applied when .theme-night on <html> */
    .theme-night{
      --bg: #101010;
      --card: linear-gradient(180deg,#0e0d12,#09080c);
      --text: #EDEDED;
      --main-counter: #3FFFD4;
      --accent: #FFB347;
      --subtext: #EDEDED;
      --tap-bg: linear-gradient(180deg, rgba(0,0,0,0.20), rgba(0,0,0,0.05));
      --om-start: #FFB347;
      --om-end:   #FF7F50;
      --om-text:  #101010;
      --tap-text:  #fff;
      --card-shadow: 0 12px 36px rgba(0,0,0,0.55);
    }

    /* ========== Base layout ========== */
    *{box-sizing:border-box}
    html,body{height:100%;margin:0;background:var(--bg);color:var(--text);font-family:Inter,system-ui,-apple-system,"Segoe UI",Roboto,Arial}
    .wrap{max-width:920px;margin:18px auto;padding:18px}
    header{display:flex;align-items:center;gap:12px;margin-bottom:10px}
    header h1{font-size:20px;margin:0;font-weight:800}

    /* ========== Om badge ========== */
    .om-circle{
      font-family:"Noto Sans Devanagari",sans-serif;
      font-size:26px;font-weight:900;
      width:52px;height:52px;border-radius:50%;
      display:flex;align-items:center;justify-content:center;
      color:var(--om-text);
      background: radial-gradient(circle, var(--om-start), var(--om-end));
      box-shadow:0 8px 22px rgba(0,0,0,0.08);
      transition: transform .18s, box-shadow .18s;
    }
    .om-pulse{ animation: omPulse 1.6s cubic-bezier(.2,.9,.3,1) 1; }
    @keyframes omPulse{ 0%,100%{ transform:scale(1); } 50%{ transform:scale(1.28); } }

    /* ========== Card UI ========== */
    .card{background:var(--card);border-radius:14px;padding:18px;box-shadow:var(--card-shadow)}
    .count-big{font-size:64px;font-weight:700;text-align:center}
    .small{font-size:13px;color:var(--subtext)}
    #count{font-weight:900;color:var(--main-counter);font-size:64px}
    #goalText{color:var(--subtext);margin-top:6px}

    button{background:var(--accent);color:#111;border:none;padding:10px 14px;border-radius:12px;cursor:pointer;font-weight:700}
    button.secondary{background:transparent;border:1px solid rgba(0,0,0,0.06)}
    input[type="number"],input[type="text"]{padding:12px;border-radius:16px;border:1px solid #eee;background:transparent;color:inherit;font-size:16px}
    progress{width:100%;height:14px;border-radius:8px;overflow:hidden;background:rgba(0,0,0,0.04)}
    progress::-webkit-progress-value{background:var(--accent)}

    .history{margin-top:14px;max-height:220px;overflow:auto;border-radius:8px;padding:8px;background:rgba(0,0,0,0.03)}
    .hist-item{font-size:13px;padding:8px;border-radius:8px;display:flex;justify-content:space-between;gap:12px}

    /* ========== TAP BUTTON (larger oval) ========== */
    .tap-wrap{ position:fixed; left:50%; transform:translateX(-50%); bottom:44px; z-index:90; width:92%; max-width:1024px; }
    .tap-btn{
      width:100%; border-radius:64px; padding:28px 32px; display:flex; justify-content:space-between; align-items:center; gap:18px; font-weight:900;
      background: var(--tap-bg); color:var(--tap-text);
      border:1px solid rgba(255,79,161,0.08);
      box-shadow:0 22px 70px rgba(0,0,0,0.08); backdrop-filter: blur(8px);
      min-height:72px;
    }
    .tap-left{ display:flex; align-items:center; gap:14px; }
    .tap-mark{ color:#ff4fa1; font-weight:900; font-size:18px }
    .tap-count{ font-size:44px; font-weight:900; color:var(--text) }
    .tap-note{ font-size:14px; opacity:.95 }

    .pill{padding:10px 14px;border-radius:28px;background:transparent;border:1px solid rgba(0,0,0,0.06);font-weight:700}

    /* ========== Overlay ========== */
    #roundOverlay{
      position:fixed; left:50%; top:50%; transform:translate(-50%,-50%); z-index:1200;
      display:none; max-width:760px; width:84%; pointer-events:none; border-radius:18px; padding:22px; text-align:center;
      backdrop-filter: blur(6px); -webkit-backdrop-filter: blur(6px);
      box-shadow: 0 20px 90px rgba(0,0,0,0.35);
    }
    .overlay-light{ background: linear-gradient(180deg, rgba(255,245,250,0.98), rgba(255,235,245,0.95)); color:#2b0720; }
    .overlay-dark{ background: linear-gradient(180deg, rgba(6,6,6,0.95), rgba(14,14,14,0.95)); color:#eee; }

    .notice{ margin-top:10px; padding:8px 10px; border-radius:10px; background:rgba(255,240,240,0.04); color:var(--subtext); font-size:13px }

    @media (max-width:420px){
      #count{font-size:48px}
      .tap-btn{padding:18px 20px; min-height:64px}
      .tap-count{ font-size:36px }
    }
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <div id="omIcon" class="om-circle" aria-hidden="true">ॐ</div>
      <h1>Chanting Counter</h1>
    </header>

    <main class="card" role="application" aria-label="Chanting counter">
      <div style="text-align:center;padding:8px 12px">
        <div class="small">Count</div>
        <div id="count" aria-live="polite">0</div>
        <div id="goalText" class="small">Goal: —</div>
      </div>

      <div style="display:flex;justify-content:space-between;align-items:center;gap:12px;flex-wrap:wrap">
        <div style="display:flex;gap:8px;align-items:center;flex-wrap:wrap">
          <button id="dec" class="secondary" aria-label="Decrease">−1</button>
          <button id="inc" aria-label="Increase">+1</button>
          <button id="reset" class="secondary" aria-label="Reset">Reset</button>
        </div>

        <div style="display:flex;gap:8px;align-items:center;flex-wrap:wrap">
          <input id="goalInput" type="number" min="1" placeholder="Goal (e.g., 21)" aria-label="Goal"/>
          <button id="setGoal" class="secondary">Set Goal</button>
        </div>
      </div>

      <div style="display:flex;justify-content:space-between;margin-top:12px;gap:12px;align-items:center">
        <div style="display:flex;gap:8px;align-items:center">
          <input id="perRound" type="number" min="1" placeholder="Per round (e.g., 21)" style="width:150px"/>
          <label style="display:flex;align-items:center;gap:8px"><input id="linkPerRound" type="checkbox" checked/> Per-round = Goal</label>
        </div>
        <div>
          <button id="clearHistoryTop" class="secondary">Clear History</button>
        </div>
      </div>

      <div style="margin-top:12px">
        <progress id="progress" max="100" value="0" aria-label="Progress"></progress>
      </div>

      <div style="display:flex;gap:8px;align-items:center;margin-top:12px;flex-wrap:wrap">
        <input id="addBy" type="number" placeholder="+ Add" style="width:120px"/>
        <button id="addBtn" class="secondary">Add</button>
        <button id="undo" class="secondary">Undo</button>

        <label class="small" style="display:flex;gap:8px;align-items:center"><input id="soundToggle" type="checkbox" checked/> Om sound</label>
        <label class="small" style="display:flex;gap:8px;align-items:center"><input id="hapticToggle" type="checkbox" checked/> Haptic</label>
      </div>

      <div style="margin-top:12px;display:flex;gap:12px;align-items:center;flex-wrap:wrap">
        <div class="pill">Rounds completed: <span id="roundsCompleted">0</span></div>
        <div class="pill">In-round: <span id="inRound">0</span>/<span id="perRoundDisplay">0</span></div>
      </div>

      <div id="vibeNotice" class="notice"></div>
      <div id="iconNotice" class="notice" style="display:none;"></div>

      <section class="history" id="history" aria-label="History"></section>
    </main>
  </div>

  <div id="roundOverlay" aria-hidden="true"></div>

  <div class="tap-wrap">
    <div id="tap" class="tap-btn" role="button" aria-label="+1 (tap)">
      <div class="tap-left">
        <div class="tap-mark">Tap</div>
        <div class="tap-count" id="tapCount">+1</div>
      </div>
      <div style="text-align:right">
        <div class="tap-note">tap</div>
      </div>
    </div>
  </div>

  <script>
  /* ==========================
     Chanting Counter — Final integrated script
     - Auto theme (system + time)
     - overlay 10s, Om 3s, end bell
     - Om pulse
     - larger oval tap button
     ========================== */

  const $ = id => document.getElementById(id);
  const countEl = $('count'), inRoundEl = $('inRound'), roundsEl = $('roundsCompleted'),
        perRoundInput = $('perRound'), perRoundDisplay = $('perRoundDisplay'),
        goalText = $('goalText'), historyEl = $('history'), progressEl = $('progress'),
        tapBtn = $('tap'), incBtn = $('inc'), decBtn = $('dec'), resetBtn = $('reset'),
        addBy = $('addBy'), addBtn = $('addBtn'), undoBtn = $('undo'),
        setGoalBtn = $('setGoal'), goalInput = $('goalInput'), linkPerRound = $('linkPerRound'),
        clearHistoryTop = $('clearHistoryTop'), soundToggle = $('soundToggle'), hapticToggle = $('hapticToggle'),
        vibeNotice = $('vibeNotice'), iconNotice = $('iconNotice'), roundOverlay = $('roundOverlay'),
        omIcon = $('omIcon');

  const STORAGE_KEY = 'chant_counter_final_v4';
  const defaultState = { totalCount:0, inRound:0, perRound:0, roundsCompleted:0, goal:null, history:[], lastAction:null, sound:true, haptic:true, sessionStart:Date.now() };
  let state = {...defaultState};

  // Audio context
  const AudioCtx = (window.AudioContext || window.webkitAudioContext) ? new (window.AudioContext || window.webkitAudioContext)() : null;

  // short chime (for tap fallback)
  function playRoundChime(){
    if(!AudioCtx) return;
    const now = AudioCtx.currentTime;
    const o = AudioCtx.createOscillator();
    const g = AudioCtx.createGain();
    o.type = 'triangle';
    o.frequency.setValueAtTime(660, now);
    o.frequency.exponentialRampToValueAtTime(240, now + 0.45);
    g.gain.setValueAtTime(0.0001, now);
    g.gain.exponentialRampToValueAtTime(0.28, now + 0.02);
    g.gain.exponentialRampToValueAtTime(0.0001, now + 0.8);
    o.connect(g); g.connect(AudioCtx.destination);
    o.start(now); o.stop(now + 0.9);
  }

  // long Om (3s)
  let __longOmStop = null;
  function playLongOm(seconds = 3){
    if(!AudioCtx) return;
    if(typeof __longOmStop === 'function'){ try{ __longOmStop(); }catch(e){}; __longOmStop = null; }

    const now = AudioCtx.currentTime;
    const dur = Math.max(0.5, seconds);
    const o1 = AudioCtx.createOscillator();
    const o2 = AudioCtx.createOscillator();
    const g = AudioCtx.createGain();
    const f = AudioCtx.createBiquadFilter();

    o1.type='sine'; o2.type='sine';
    o1.frequency.setValueAtTime(110, now);
    o2.frequency.setValueAtTime(220, now);

    f.type='lowpass'; f.frequency.setValueAtTime(1200, now); f.Q.setValueAtTime(0.8, now);

    g.gain.setValueAtTime(0.0001, now);
    g.gain.linearRampToValueAtTime(0.18, now + 0.22);
    g.gain.setValueAtTime(0.18, now + dur - 0.45);
    g.gain.exponentialRampToValueAtTime(0.0001, now + dur);

    o1.connect(f); o2.connect(f); f.connect(g); g.connect(AudioCtx.destination);
    o2.detune.value = 6 * (Math.random() - 0.5);

    o1.start(now); o2.start(now);
    o1.stop(now + dur + 0.05); o2.stop(now + dur + 0.05);

    __longOmStop = ()=>{ try{o1.stop(); o2.stop();}catch(e){}; try{ g.gain.exponentialRampToValueAtTime(0.0001, AudioCtx.currentTime + 0.05);}catch(e){}; __longOmStop = null; };
    setTimeout(()=>{ __longOmStop = null; }, (dur+0.3)*1000);
  }

  // end bell (short) after overlay finishes
  function playEndBell(){
    if(!AudioCtx) return;
    const now = AudioCtx.currentTime;
    const a = AudioCtx.createOscillator();
    const b = AudioCtx.createOscillator();
    const g = AudioCtx.createGain();
    const h = AudioCtx.createBiquadFilter();

    a.type='sine'; b.type='sine';
    a.frequency.setValueAtTime(1100, now); b.frequency.setValueAtTime(1320, now);
    g.gain.setValueAtTime(0.0001, now);
    g.gain.exponentialRampToValueAtTime(0.28, now + 0.01);
    g.gain.exponentialRampToValueAtTime(0.0001, now + 0.8);
    h.type='highpass'; h.frequency.setValueAtTime(600, now);

    a.connect(h); b.connect(h); h.connect(g); g.connect(AudioCtx.destination);
    a.start(now); b.start(now); a.stop(now + 0.75); b.stop(now + 0.75);
  }

  // small visual confetti
  function createConfettiBurst(n){
    for(let i=0;i<n;i++){
      const d = document.createElement('div');
      d.style.position='fixed';
      d.style.left = (50 + (Math.random()*60 - 30)) + '%';
      d.style.top  = (50 + (Math.random()*10 - 5)) + '%';
      const s = (6 + Math.random()*8) + 'px';
      d.style.width = d.style.height = s;
      d.style.background = ['#ffd6e8','#ff9acb','#ffc1e3','#ffbfdc'][Math.floor(Math.random()*4)];
      d.style.borderRadius = '3px';
      d.style.zIndex = 1210;
      document.body.appendChild(d);
      const dx = (Math.random()*160 - 80);
      const dy = -80 - Math.random()*160;
      d.animate([{ transform:'translate(0,0) rotate(0deg)', opacity:1 }, { transform:`translate(${dx}px, ${dy}px) rotate(${Math.random()*360}deg)`, opacity:0 }], { duration: 900 + Math.random()*500, easing:'cubic-bezier(.2,.8,.2,1)'});
      setTimeout(()=> d.remove(), 1500);
    }
  }

  // Overlay: visible 10s, fade, then bell
  function showRoundCompleteAnimation(){
    if(!roundOverlay) return;
    roundOverlay.className = document.documentElement.classList.contains('theme-night') ? 'overlay-dark' : 'overlay-light';
    roundOverlay.innerHTML = `<div style="font-size:20px;font-weight:800;margin-bottom:8px;">Round complete</div>
                              <div style="font-size:52px;font-weight:900;letter-spacing:1px">ॐ · <span id="roundPlus">${state.perRound || 0}</span></div>`;

    try{ if(roundOverlay.__hideTimeout){ clearTimeout(roundOverlay.__hideTimeout); roundOverlay.__hideTimeout = null; } }catch(e){}

    roundOverlay.style.display = 'block';
    roundOverlay.style.opacity = '1';
    roundOverlay.style.pointerEvents = 'none';
    roundOverlay.animate([{ opacity:0, transform:'translate(-50%,-50%) scale(0.94)' }, { opacity:1, transform:'translate(-50%,-50%) scale(1.03)' }, { opacity:1, transform:'translate(-50%,-50%) scale(1)' }], { duration:380, easing:'cubic-bezier(.2,.9,.3,1)', fill:'forwards' });

    try{ createConfettiBurst(12); } catch(e){}

    // keep visible 10s, then fade and play end bell
    roundOverlay.__hideTimeout = setTimeout(()=>{
      const anim = roundOverlay.animate([{ opacity:1, transform:'translate(-50%,-50%) scale(1)' }, { opacity:0, transform:'translate(-50%,-50%) scale(0.94)' }], { duration:520, easing:'ease', fill:'forwards' });
      anim.onfinish = ()=>{
        roundOverlay.style.display = 'none';
        roundOverlay.__hideTimeout = null;
        if(state.sound && AudioCtx) try{ playEndBell(); } catch(e){}
      };
      // fallback
      setTimeout(()=>{
        if(roundOverlay.__hideTimeout !== null){
          roundOverlay.style.display='none'; roundOverlay.__hideTimeout = null;
          if(state.sound && AudioCtx) try{ playEndBell(); } catch(e){}
        }
      }, 800);
    }, 10000); // 10,000 ms = 10 seconds
  }

  // Om badge visual pulse
  function pulseOmIcon(){
    if(!omIcon) return;
    omIcon.classList.remove('om-pulse');
    void omIcon.offsetWidth;
    omIcon.classList.add('om-pulse');
  }

  // When round completes: vibration/sound -> overlay -> long Om(3s) -> pulse
  function handleRoundComplete(){
    if(state.haptic && 'vibrate' in navigator){ try{ navigator.vibrate([50,40,50]); }catch(e){} }
    else { if(state.sound && AudioCtx){ if(AudioCtx.state==='suspended') AudioCtx.resume(); playRoundChime(); } }

    showRoundCompleteAnimation();

    if(state.sound && AudioCtx){ if(AudioCtx.state==='suspended') AudioCtx.resume(); playLongOm(3); }

    pulseOmIcon();
  }

  // persistence
  function save(){ localStorage.setItem(STORAGE_KEY, JSON.stringify(state)); }
  function load(){ try{ const s = JSON.parse(localStorage.getItem(STORAGE_KEY)); if(s) state = {...defaultState, ...s}; }catch(e){} }

  function render(){
    countEl.textContent = state.totalCount;
    inRoundEl.textContent = state.inRound;
    perRoundDisplay.textContent = state.perRound || 0;
    roundsEl.textContent = state.roundsCompleted;
    progressEl.value = state.goal ? Math.min(100, Math.round((state.totalCount/state.goal)*100)) : (state.perRound ? Math.min(100, Math.floor((state.inRound/state.perRound)*100)) : 0);
    goalText.textContent = state.goal ? `Goal: ${state.goal} · ${state.totalCount}/${state.goal} (${Math.min(100, Math.round((state.totalCount/state.goal)*100))}%)` : 'Goal: —';
    soundToggle.checked = state.sound; hapticToggle.checked = state.haptic;
    perRoundInput.value = state.perRound || '';
    renderHistory();
    updateVibeNotice(); save();
  }

  function renderHistory(){
    historyEl.innerHTML = '';
    if(!state.history || state.history.length === 0){ historyEl.innerHTML = '<div class="small">No history yet</div>'; return; }
    state.history.slice().reverse().forEach(it=>{
      const d = new Date(it.t);
      const div = document.createElement('div');
      div.className = 'hist-item';
      div.style.display = 'flex';
      div.style.justifyContent = 'space-between';
      div.innerHTML = `<div>${it.delta>0?'+':''}${it.delta} → total ${it.totalCount} · in-round ${it.inRound}</div><div class="small">${d.toLocaleString()}</div>`;
      historyEl.appendChild(div);
    });
  }

  const vibrationSupported = 'vibrate' in navigator;
  function updateVibeNotice(){ if(!vibrationSupported) vibeNotice.textContent = 'Note: vibration unavailable in this browser (iOS Safari often does not support it). Sound fallback will be used.'; else vibeNotice.textContent=''; }

  // apply change and compute rounds
  function applyDelta(delta, record=true){
    const prevRounds = state.roundsCompleted;
    state.totalCount = (state.totalCount || 0) + delta;
    if(state.totalCount < 0) state.totalCount = 0;

    if(linkPerRound.checked) state.perRound = state.goal || 0;
    else state.perRound = parseInt(perRoundInput.value) || state.perRound || 0;

    if(state.perRound > 0){
      state.inRound = (state.inRound || 0) + delta;
      if(state.inRound < 0){
        if(state.roundsCompleted > 0){ state.roundsCompleted = Math.max(0, state.roundsCompleted - 1); state.inRound = state.perRound + state.inRound; } else state.inRound = 0;
      }
      while(state.inRound >= state.perRound){ state.inRound -= state.perRound; state.roundsCompleted += 1; }
    } else { state.inRound = state.totalCount; state.roundsCompleted = 0; }

    if(record){ const entry = { t: Date.now(), delta, totalCount: state.totalCount, inRound: state.inRound }; state.history.push(entry); state.lastAction = entry; }

    // feedback
    if(state.haptic && vibrationSupported){ try{ navigator.vibrate(28); }catch(e){ if(state.sound && AudioCtx){ if(AudioCtx.state==='suspended') AudioCtx.resume(); playRoundChime(); } } }
    else { if(state.sound && AudioCtx){ if(AudioCtx.state==='suspended') AudioCtx.resume(); playRoundChime(); } }

    const newRound = state.roundsCompleted > prevRounds;
    render();
    if(newRound) handleRoundComplete();
    return newRound;
  }

  function undo(){ if(!state.lastAction) return; for(let i=state.history.length-1;i>=0;i--){ if(state.history[i].t === state.lastAction.t){ state.history.splice(i,1); break; } } const last = state.history[state.history.length-1]; if(last){ state.totalCount = last.totalCount; state.inRound = last.inRound; state.roundsCompleted = Math.floor(state.totalCount/state.perRound); } else { state.totalCount=0; state.inRound=0; state.roundsCompleted=0; } state.lastAction=null; render(); }

  // events
  incBtn.addEventListener('click', ()=> applyDelta(1));
  decBtn.addEventListener('click', ()=> applyDelta(-1));
  resetBtn.addEventListener('click', ()=> { if(confirm('Reset total and in-round counts?')){ state.totalCount=0; state.inRound=0; state.roundsCompleted=0; state.history.push({t:Date.now(), delta:0, totalCount:0, inRound:0, note:'reset'}); render(); }});
  addBtn.addEventListener('click', ()=> { const n = parseInt(addBy.value); if(!isNaN(n) && n!==0){ applyDelta(n); addBy.value=''; }});
  undoBtn.addEventListener('click', undo);
  setGoalBtn.addEventListener('click', ()=> { const g = parseInt(goalInput.value); if(!g || g<=0){ state.goal=null; alert('Enter valid goal > 0 or clear'); return; } state.goal = g; if(linkPerRound.checked) state.perRound = g; render(); });
  clearHistoryTop.addEventListener('click', ()=> { if(confirm('Clear history?')){ state.history=[]; render(); }});
  soundToggle.addEventListener('change', e => { state.sound = e.target.checked; save(); });
  hapticToggle.addEventListener('change', e => { state.haptic = e.target.checked; save(); });

  perRoundInput.addEventListener('change', ()=> { const v = parseInt(perRoundInput.value); if(!linkPerRound.checked && v && v>0){ state.perRound = v; state.roundsCompleted = Math.floor(state.totalCount/state.perRound); state.inRound = state.totalCount % state.perRound; render(); }});
  linkPerRound.addEventListener('change', ()=> { if(linkPerRound.checked){ state.perRound = state.goal || 0; perRoundInput.disabled = true; } else { perRoundInput.disabled = false; } render(); });

  tapBtn.addEventListener('click', ()=> applyDelta(1));
  window.addEventListener('keydown', (e) => { if(e.code === 'Space'){ e.preventDefault(); applyDelta(1); } if(e.code === 'Backspace'){ e.preventDefault(); applyDelta(-1); } });

  // resume audio on first interaction
  ['click','touchstart','keydown'].forEach(evt => { window.addEventListener(evt,function resume(){ if(AudioCtx && AudioCtx.state === 'suspended') AudioCtx.resume(); window.removeEventListener(evt, resume); }); });

  // icons check
  async function checkIcons(){
    try{
      const r1 = await fetch('./icons/icon-192.png', { method:'HEAD' });
      const r2 = await fetch('./icons/icon-512.png', { method:'HEAD' });
      if(r1.ok && r2.ok){ iconNotice.style.display='none'; return true; }
      iconNotice.style.display='block'; iconNotice.innerText='App icons not found: upload ./icons/icon-192.png and ./icons/icon-512.png for proper home-screen icons.';
      return false;
    } catch(e){ iconNotice.style.display='block'; iconNotice.innerText='Could not check icons (network). Ensure ./icons/icon-192.png and ./icons/icon-512.png are present.'; return false; }
  }

  // ========== Auto theme (system preference + time heuristic) ==========
  // call setDynamicTheme(true) at init
  function setDynamicTheme(enable){
    if(!enable) return;
    const mq = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)');
    // function to apply theme
    function apply(){
      const prefersDark = mq ? mq.matches : false;
      const h = new Date().getHours();
      const isNight = prefersDark || (h >= 18 || h < 6);
      document.documentElement.classList.toggle('theme-night', isNight);
    }
    // initial apply
    apply();
    // listen to changes in system preference
    if(mq && mq.addEventListener) mq.addEventListener('change', apply);
    else if(mq && mq.addListener) mq.addListener(apply);
    // also re-evaluate at hour-change (simple timer) to pick up time-of-day shifts
    setInterval(apply, 60 * 1000); // every minute (cheap)
  }

  // init
  load();
  if(!state.sessionStart) state.sessionStart = Date.now();
  if(linkPerRound.checked){ perRoundInput.disabled = true; if(state.goal) state.perRound = state.goal; }
  render();
  checkIcons();

  // enable auto theme switching
  setDynamicTheme(true);

  // register service worker (if present)
  if('serviceWorker' in navigator){
    navigator.serviceWorker.register('./service-worker.js').then(reg => console.log('SW registered', reg)).catch(err => console.warn('SW registration failed', err));
  }
  </script>
</body>
</html>