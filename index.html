<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Chanting Counter — with Om & Rounds</title>
  <style>
    :root{
      --bg:#fff7fb; --card:#fff; --accent:#ff4fa1; --muted:#6b6f76;
      --glass: rgba(255,79,161,0.12);
      --glass-2: rgba(255,255,255,0.6);
      --danger:#ef4444;
    }
    *{box-sizing:border-box}
    html,body{height:100%; margin:0; font-family:Inter, "Segoe UI", Roboto, Arial; background:var(--bg); color:#0f172a}
    .wrap{max-width:920px; margin:20px auto; padding:18px;}
    header{display:flex; align-items:center; gap:12px; margin-bottom:10px}
    header h1{font-size:20px; margin:0}
    .card{background:var(--card); border-radius:14px; padding:18px; box-shadow:0 10px 30px rgba(22,28,45,0.06)}
    .count-big{font-size:64px; font-weight:700; text-align:center}
    .muted{color:var(--muted)}
    .controls{display:flex; gap:10px; justify-content:center; margin-top:12px; flex-wrap:wrap}
    button{background:var(--accent); color:white; border:none; padding:12px 16px; border-radius:12px; font-weight:600; cursor:pointer}
    button.secondary{background:#fff; color:#111; border:1px solid #eef2f7; box-shadow:none}
    button.warn{background:var(--danger)}
    input[type="number"], input[type="text"]{padding:10px 12px; border-radius:8px; border:1px solid #eee; min-width:100px}
    progress{width:100%; height:14px; border-radius:8px; overflow:hidden}
    .row{display:flex; gap:10px; align-items:center; flex-wrap:wrap}
    .small{font-size:13px; color:var(--muted)}
    .history{margin-top:14px; max-height:160px; overflow:auto; border-radius:8px; padding:8px; background:#fffafc}
    .hist-item{font-size:13px; padding:8px; border-radius:8px; display:flex; justify-content:space-between; gap:12px}
    .settings{display:flex; gap:8px; align-items:center; flex-wrap:wrap}
    /* Big translucent tap button (mobile) */
    .tap-wrap{
      position:fixed;
      left:50%;
      transform:translateX(-50%);
      bottom:18px;
      z-index:60;
      width:86%;
      max-width:760px;
      pointer-events:none; /* inner button will accept pointer */
    }
    .tap-btn{
      pointer-events:auto;
      width:100%;
      border-radius:34px;
      padding:18px 12px;
      text-align:center;
      backdrop-filter: blur(6px);
      -webkit-backdrop-filter: blur(6px);
      background: linear-gradient(180deg, rgba(255,255,255,0.55), rgba(255,79,161,0.06));
      border: 1px solid rgba(255,79,161,0.12);
      box-shadow: 0 8px 30px rgba(255,79,161,0.12), inset 0 1px 0 rgba(255,255,255,0.6);
      font-size:22px;
      font-weight:700;
      color:#1f1f29;
      display:flex;
      align-items:center;
      justify-content:center;
      gap:14px;
    }
    .tap-count{font-size:28px; font-weight:800; color:#111}
    .small-pill{padding:8px 12px; border-radius:20px; background:#fff; border:1px solid #f0f0f3; font-weight:600}
    @media (max-width:560px){
      .count-big{font-size:46px}
      .tap-btn{padding:16px; font-size:18px}
    }
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <svg width="36" height="36" viewBox="0 0 24 24" aria-hidden><path fill="#ff4fa1" d="M12 2L3 20h18L12 2z"></path></svg>
      <h1>Chanting Counter</h1>
    </header>

    <div class="card" role="application" aria-label="Chanting counter application">
      <div style="text-align:center; padding:8px 12px;">
        <div class="small muted">Count</div>
        <div id="count" class="count-big" aria-atomic="true">0</div>
        <div id="goalText" class="muted small">Goal: —</div>
      </div>

      <div class="controls">
        <button id="dec" class="secondary" aria-label="Decrease">−1</button>
        <button id="inc" aria-label="Increase">+1</button>
        <button id="reset" class="warn" aria-label="Reset">Reset</button>
      </div>

      <div style="margin-top:12px; display:flex; gap:10px; align-items:center; flex-wrap:wrap;">
        <input id="goalInput" type="number" min="1" placeholder="Goal (e.g., 108)" aria-label="Goal count" />
        <button id="setGoal" class="secondary">Set Goal</button>

        <input id="perRound" type="number" min="1" placeholder="Per round (108)" aria-label="Per round" style="width:120px"/>
        <button id="toggleAutoRound" class="secondary">Auto-round: On</button>
      </div>

      <div style="margin-top:10px;">
        <progress id="progress" max="100" value="0" aria-label="Progress"></progress>
      </div>

      <div style="margin-top:12px; display:flex; gap:12px; align-items:center; flex-wrap:wrap;">
        <input id="addBy" type="number" placeholder="+ Add" aria-label="Add custom amount" />
        <button id="addBtn" class="secondary">Add</button>
        <button id="undo" class="secondary">Undo</button>

        <label class="small" style="display:flex; gap:8px; align-items:center;">
          <input id="soundToggle" type="checkbox" checked /> Om sound
        </label>

        <label class="small" style="display:flex; gap:8px; align-items:center;">
          <input id="keepScreen" type="checkbox" /> Keep screen on
        </label>
      </div>

      <div style="margin-top:12px; display:flex; gap:12px; align-items:center; flex-wrap:wrap;">
        <div class="small-pill">Rounds completed: <span id="roundsCompleted">0</span></div>
        <div class="small-pill">In-round: <span id="inRound">0</span>/<span id="perRoundDisplay">108</span></div>
        <div class="small" id="sessionTimer">Session: 00:00:00</div>
      </div>

      <div class="history" id="history" aria-label="History">
        <!-- history -->
      </div>

      <div style="margin-top:12px; display:flex; gap:8px; flex-wrap:wrap;">
        <button id="export" class="secondary">Export CSV</button>
        <button id="clearHistory" class="secondary">Clear History</button>
      </div>
    </div>
  </div>

  <!-- Big translucent tap button -->
  <div class="tap-wrap" aria-hidden="false">
    <div id="tap" class="tap-btn" role="button" aria-label="+1 (tap)">
      <div style="display:flex; flex-direction:column; align-items:center;">
        <div style="font-size:14px; color:#7a2b4f; opacity:0.9">Tap</div>
        <div class="tap-count">+1</div>
      </div>
      <div style="margin-left:auto;">
        <div class="small" style="opacity:0.85">tap</div>
      </div>
    </div>
  </div>

<script>
  // DOM
  const countEl = document.getElementById('count');
  const incBtn = document.getElementById('inc');
  const decBtn = document.getElementById('dec');
  const resetBtn = document.getElementById('reset');
  const goalInput = document.getElementById('goalInput');
  const setGoalBtn = document.getElementById('setGoal');
  const progress = document.getElementById('progress');
  const goalText = document.getElementById('goalText');
  const addBy = document.getElementById('addBy');
  const addBtn = document.getElementById('addBtn');
  const historyEl = document.getElementById('history');
  const exportBtn = document.getElementById('export');
  const clearHistoryBtn = document.getElementById('clearHistory');
  const undoBtn = document.getElementById('undo');
  const tapBtn = document.getElementById('tap');
  const perRoundInput = document.getElementById('perRound');
  const roundsCompletedEl = document.getElementById('roundsCompleted');
  const inRoundEl = document.getElementById('inRound');
  const perRoundDisplay = document.getElementById('perRoundDisplay');
  const toggleAutoRoundBtn = document.getElementById('toggleAutoRound');
  const soundToggle = document.getElementById('soundToggle');
  const keepScreen = document.getElementById('keepScreen');
  const sessionTimerEl = document.getElementById('sessionTimer');

  // State
  const STORAGE_KEY = 'chant_counter_v2';
  let state = {
    totalCount: 0,       // cumulative
    inRoundCount: 0,     // count within current round (0 .. perRound-1)
    perRound: 108,
    roundsCompleted: 0,
    goal: null,
    history: [],         // {t, delta, totalCount, inRound}
    lastAction: null,
    autoRound: true,
    sessionStart: Date.now()
  };

  // WebAudio "Om-like" generator
  const AudioCtx = (window.AudioContext || window.webkitAudioContext) ? new (window.AudioContext || window.webkitAudioContext)() : null;
  function playOm(){
    if(!AudioCtx) return;
    // create a warm harmonic Om-ish tone: low fundamental + gentle harmonic + vowel-ish envelope
    const now = AudioCtx.currentTime;
    const base = AudioCtx.createOscillator();
    const harm = AudioCtx.createOscillator();
    const gain = AudioCtx.createGain();
    const gain2 = AudioCtx.createGain();

    base.type = 'sine'; base.frequency.value = 110; // low
    harm.type = 'sine'; harm.frequency.value = 220; // octave

    gain.gain.value = 0.0001;
    gain2.gain.value = 0.0001;

    base.connect(gain);
    harm.connect(gain2);
    gain.connect(AudioCtx.destination);
    gain2.connect(AudioCtx.destination);

    // Envelope: quick attack, slow decay
    gain.gain.setValueAtTime(0.0001, now);
    gain.gain.exponentialRampToValueAtTime(0.18, now + 0.02);
    gain.gain.exponentialRampToValueAtTime(0.001, now + 0.85);

    gain2.gain.setValueAtTime(0.0001, now);
    gain2.gain.exponentialRampToValueAtTime(0.09, now + 0.03);
    gain2.gain.exponentialRampToValueAtTime(0.0001, now + 0.85);

    base.start(now);
    harm.start(now);
    base.stop(now + 0.9);
    harm.stop(now + 0.9);
  }

  // save/load
  function save(){ localStorage.setItem(STORAGE_KEY, JSON.stringify(state)); }
  function load(){
    try{
      const s = JSON.parse(localStorage.getItem(STORAGE_KEY));
      if(s) state = {...state, ...s};
    }catch(e){}
  }

  // UI render
  function render(){
    countEl.textContent = state.totalCount;
    inRoundEl.textContent = state.inRoundCount;
    perRoundDisplay.textContent = state.perRound;
    roundsCompletedEl.textContent = state.roundsCompleted;
    goalText.textContent = state.goal ? `Goal: ${state.goal} · ${state.totalCount}/${state.goal} (${Math.min(100, Math.round((state.totalCount/state.goal)*100))}%)` : 'Goal: —';
    const prog = state.goal ? Math.min(100, Math.round((state.totalCount/state.goal)*100)) : Math.min(100, Math.floor((state.inRoundCount/state.perRound)*100));
    progress.value = prog;
    toggleAutoRoundBtn.textContent = `Auto-round: ${state.autoRound ? 'On' : 'Off'}`;
    renderHistory();
    save();
  }

  function renderHistory(){
    historyEl.innerHTML = '';
    if(state.history.length===0){
      historyEl.innerHTML = '<div class="small muted">No history yet</div>';
      return;
    }
    state.history.slice().reverse().forEach(it=>{
      const d = new Date(it.t);
      const row = document.createElement('div');
      row.className = 'hist-item';
      row.innerHTML = `<div style="color:#111">${it.delta>0?'+':''}${it.delta} → total ${it.totalCount} · in-round ${it.inRound}</div><div class="small">${d.toLocaleString()}</div>`;
      historyEl.appendChild(row);
    });
  }

  // core change handler
  function change(delta, record=true){
    state.totalCount += delta;
    if(state.totalCount < 0) state.totalCount = 0;

    // update in-round depending on mode:
    if(state.autoRound){
      state.inRoundCount += delta;
      // handle negative
      if(state.inRoundCount < 0){
        // borrow from roundsCompleted if available
        if(state.roundsCompleted > 0){
          state.roundsCompleted = Math.max(0, state.roundsCompleted - 1);
          state.inRoundCount = state.perRound + state.inRoundCount; // negative adjustment
        } else {
          state.inRoundCount = 0;
        }
      }

      // if inRound reaches perRound or exceeds, carry over multiple rounds
      while(state.inRoundCount >= state.perRound){
        state.inRoundCount -= state.perRound;
        state.roundsCompleted += 1;
      }
    } else {
      // cumulative mode: compute rounds from totalCount
      state.inRoundCount = state.totalCount % state.perRound;
      state.roundsCompleted = Math.floor(state.totalCount / state.perRound);
    }

    if(record){
      const entry = {t: Date.now(), delta, totalCount: state.totalCount, inRound: state.inRoundCount};
      state.history.push(entry);
      state.lastAction = entry;
    }

    // feedback
    if(soundToggle.checked) {
      // resume audio context if suspended
      if(AudioCtx && AudioCtx.state === 'suspended') { AudioCtx.resume(); }
      playOm();
    }
    // vibrate if available
    if(navigator.vibrate) navigator.vibrate(20);
    render();
  }

  function undo(){
    if(!state.lastAction) return;
    // remove last matching entry (by timestamp)
    for(let i=state.history.length-1;i>=0;i--){
      if(state.history[i].t === state.lastAction.t){
        state.history.splice(i,1);
        break;
      }
    }
    // restore from remaining last entry or recalc
    const last = state.history[state.history.length-1];
    if(last){
      state.totalCount = last.totalCount;
      state.inRoundCount = last.inRound;
      if(!state.autoRound){
        state.roundsCompleted = Math.floor(state.totalCount / state.perRound);
      } else {
        // keep roundsCompleted as stored previously by recomputing from history
        let rounds = 0, inR = 0;
        // recompute from scratch
        let tot = 0;
        for(const h of state.history){
          tot = h.totalCount;
        }
        state.totalCount = tot;
        state.inRoundCount = state.autoRound ? (state.inRoundCount % state.perRound) : state.totalCount % state.perRound;
        if(!state.autoRound) state.roundsCompleted = Math.floor(state.totalCount / state.perRound);
      }
    } else {
      // no history left
      state.totalCount = 0;
      state.inRoundCount = 0;
      state.roundsCompleted = 0;
    }
    state.lastAction = null;
    render();
  }

  // Buttons
  incBtn.addEventListener('click', ()=> change(1));
  decBtn.addEventListener('click', ()=> change(-1));
  resetBtn.addEventListener('click', ()=>{
    if(!confirm('Reset total and in-round counts?')) return;
    state.totalCount = 0; state.inRoundCount = 0; state.roundsCompleted = 0;
    state.history.push({t:Date.now(), delta:0, totalCount:0, inRound:0, note:'reset'});
    render();
  });

  setGoalBtn.addEventListener('click', ()=>{
    const g = parseInt(goalInput.value);
    if(!g || g<=0){ state.goal = null; alert('Enter a valid goal > 0 or clear to remove'); return; }
    state.goal = g;
    render();
  });

  addBtn.addEventListener('click', ()=>{
    const n = parseInt(addBy.value);
    if(isNaN(n) || n===0) return;
    change(n);
    addBy.value = '';
  });

  exportBtn.addEventListener('click', ()=>{
    if(state.history.length===0){ alert('No history to export'); return; }
    let csv = 'timestamp,delta,totalCount,inRound\\n';
    state.history.forEach(it => {
      csv += `"${new Date(it.t).toISOString()}",${it.delta},${it.totalCount},${it.inRound}\\n`;
    });
    const blob = new Blob([csv], {type:'text/csv'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url; a.download = 'chant_history.csv'; document.body.appendChild(a); a.click(); a.remove();
    URL.revokeObjectURL(url);
  });

  clearHistoryBtn.addEventListener('click', ()=>{
    if(!confirm('Clear history?')) return;
    state.history = [];
    render();
  });

  undoBtn.addEventListener('click', undo);

  // keyboard shortcuts
  window.addEventListener('keydown', (e)=>{
    if(e.code === 'Space'){ e.preventDefault(); change(1); }
    if(e.code === 'Backspace'){ e.preventDefault(); change(-1); }
  });

  // long-press / continuous support for tap & inc/dec
  function attachLongPress(el, delta){
    let timer=null, interval=null;
    const start = (ev) => {
      ev.preventDefault();
      // first immediate change
      change(delta);
      timer = setTimeout(()=> {
        interval = setInterval(()=> change(delta), 120);
      }, 350);
    };
    const stop = () => {
      if(timer) clearTimeout(timer);
      if(interval) { clearInterval(interval); interval=null; }
    };
    el.addEventListener('pointerdown', start);
    window.addEventListener('pointerup', stop);
    el.addEventListener('pointerleave', stop);
    el.addEventListener('pointercancel', stop);
  }
  attachLongPress(incBtn, 1);
  attachLongPress(decBtn, -1);
  attachLongPress(tapBtn, 1);

  // tap button also responds to click/tap
  tapBtn.addEventListener('click', ()=> change(1));

  // per-round input / toggle behavior
  perRoundInput.addEventListener('change', ()=>{
    const v = parseInt(perRoundInput.value);
    if(v && v>0){
      state.perRound = v;
      // recompute inRound and rounds depending on mode
      if(!state.autoRound){
        state.roundsCompleted = Math.floor(state.totalCount / state.perRound);
        state.inRoundCount = state.totalCount % state.perRound;
      } else {
        // when switching size keep present inRound as modulo
        state.inRoundCount = state.totalCount % state.perRound;
      }
      render();
    }
  });

  toggleAutoRoundBtn.addEventListener('click', ()=>{
    state.autoRound = !state.autoRound;
    // recompute counters to reflect mode
    if(state.autoRound){
      // convert cumulative to auto style: keep roundsCompleted as is and inRound from totalCount
      const total = state.totalCount;
      state.roundsCompleted = Math.floor(total / state.perRound);
      state.inRoundCount = total % state.perRound;
    } else {
      // cumulative mode: ensure rounds = floor(total/perRound)
      state.inRoundCount = state.totalCount % state.perRound;
      state.roundsCompleted = Math.floor(state.totalCount / state.perRound);
    }
    render();
  });

  // Keep screen on (simple approach using Wake Lock API)
  let wakeLock = null;
  keepScreen.addEventListener('change', async ()=>{
    if(keepScreen.checked){
      try{
        if('wakeLock' in navigator){
          wakeLock = await navigator.wakeLock.request('screen');
          wakeLock.addEventListener('release', ()=> { keepScreen.checked = false; });
        } else {
          // fallback: do nothing, browser may not support
          console.log('Wake Lock not supported in this browser');
        }
      }catch(e){
        console.log('Wake Lock request failed', e);
      }
    } else {
      if(wakeLock){ wakeLock.release(); wakeLock = null; }
    }
  });

  // Session timer
  function tickSession(){
    const diff = Date.now() - state.sessionStart;
    const s = Math.floor(diff/1000)%60;
    const m = Math.floor(diff/60000)%60;
    const h = Math.floor(diff/3600000);
    sessionTimerEl.textContent = `Session: ${String(h).padStart(2,'0')}:${String(m).padStart(2,'0')}:${String(s).padStart(2,'0')}`;
  }
  setInterval(tickSession, 1000);

  // Init
  load();
  if(!state.sessionStart) state.sessionStart = Date.now();
  // ensure defaults shown
  perRoundInput.value = state.perRound;
  render();

  // Autoresume audio context on first user gesture
  ['click','touchstart','keydown'].forEach(evt=>{
    window.addEventListener(evt, function resume(){
      if(AudioCtx && AudioCtx.state === 'suspended') AudioCtx.resume();
      window.removeEventListener(evt, resume);
    });
  });

  // Focus friendly
  incBtn.focus();
</script>
</body>
</html>
