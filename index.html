<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Chanting Counter — PWA + Haptics</title>

  <!-- Manifest (relative path so works from /counter/ on GitHub Pages) -->
  <link rel="manifest" href="./manifest.json" />

  <!-- Preferred PNG icons (recommended) -->
  <link rel="icon" href="./icons/icon-192.png" sizes="192x192" type="image/png">
  <link rel="apple-touch-icon" href="./icons/icon-512.png" sizes="512x512">

  <!-- Fallback mask/icon -->
  <link rel="mask-icon" href="./icons/icon-192.svg" color="#ff4fa1">

  <meta name="theme-color" content="#0b0b0d" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

  <style>
    :root{--bg:#fff7fb;--card:#fff;--accent:#ff4fa1;--muted:#6b6f76;--text:#0f172a;--tap-text:#111;--progress-fill:#2f9a3f;}
    @media (prefers-color-scheme:dark){:root{--bg:#07060a;--card:linear-gradient(180deg,#09080c,#0e0d12);--accent:#ff6fb0;--muted:#9aa0a6;--text:#e8e8ec;--tap-text:#fff;--progress-fill:#36b37e;}}
    *{box-sizing:border-box}
    html,body{height:100%;margin:0;font-family:Inter,system-ui,-apple-system,"Segoe UI",Roboto,Arial;background:var(--bg);color:var(--text)}
    .wrap{max-width:920px;margin:18px auto;padding:18px;}
    header{display:flex;align-items:center;gap:12px;margin-bottom:10px}
    header h1{font-size:20px;margin:0}
    .card{background:var(--card);border-radius:14px;padding:18px;box-shadow:0 12px 36px rgba(0,0,0,0.06)}
    .count-big{font-size:64px;font-weight:700;text-align:center}
    .small{font-size:13px;color:var(--muted)}
    button{background:var(--accent);color:white;border:none;padding:10px 14px;border-radius:12px;cursor:pointer;font-weight:700}
    button.secondary{background:transparent;color:var(--text);border:1px solid rgba(0,0,0,0.06)}
    input[type="number"], input[type="text"]{padding:12px;border-radius:16px;border:1px solid #eee;min-width:120px;background:transparent;color:var(--text);font-size:16px}
    progress{width:100%;height:14px;border-radius:8px;overflow:hidden}
    .history{margin-top:14px;max-height:220px;overflow:auto;border-radius:8px;padding:8px;background:rgba(0,0,0,0.03)}
    .hist-item{font-size:13px;padding:8px;border-radius:8px;display:flex;justify-content:space-between;gap:12px}
    .tap-wrap{position:fixed;left:50%;transform:translateX(-50%);bottom:14px;z-index:80;width:96%;max-width:1000px}
    .tap-btn{pointer-events:auto;width:100%;border-radius:48px;padding:30px 22px;text-align:center;backdrop-filter:blur(8px);background:linear-gradient(180deg,rgba(255,255,255,0.55),rgba(255,79,161,0.06));border:1px solid rgba(255,79,161,0.12);box-shadow:0 16px 50px rgba(255,79,161,0.12);display:flex;justify-content:space-between;align-items:center;gap:18px;font-weight:900;color:var(--tap-text)}
    .tap-count{font-size:44px}
    .tap-note{font-size:14px;opacity:0.95}
    .pill{padding:10px 14px;border-radius:28px;background:var(--card);border:1px solid rgba(0,0,0,0.04);font-weight:700}
    #roundOverlay{position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);z-index:1200;display:none;max-width:760px;width:84%;pointer-events:none;border-radius:20px;padding:22px;text-align:center;backdrop-filter: blur(6px);-webkit-backdrop-filter: blur(6px);box-shadow: 0 16px 60px rgba(255,100,150,0.12)}
    @media (prefers-color-scheme: dark){ #roundOverlay{background: linear-gradient(180deg, rgba(20,18,20,0.92), rgba(30,26,30,0.86)); color: var(--text);} }
    @media (prefers-color-scheme: light){ #roundOverlay{background: linear-gradient(180deg, rgba(255,245,250,0.98), rgba(255,235,245,0.95)); color: #2b0720;} }
    .notice{margin-top:10px;padding:8px 10px;border-radius:10px;background:rgba(255,240,240,0.04);color:var(--muted);font-size:13px}
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <svg width="36" height="36" viewBox="0 0 24 24" aria-hidden><path fill="#ff4fa1" d="M12 2L3 20h18L12 2z"/></svg>
      <h1>Chanting Counter</h1>
    </header>

    <main class="card" role="application" aria-label="Chanting counter">
      <div style="text-align:center; padding:8px 12px">
        <div class="small">Count</div>
        <div id="count" class="count-big" aria-live="polite">0</div>
        <div id="goalText" class="small">Goal: —</div>
      </div>

      <div style="display:flex; justify-content:space-between; align-items:center; gap:12px; flex-wrap:wrap;">
        <div style="display:flex; gap:8px; align-items:center; flex-wrap:wrap;">
          <button id="dec" class="secondary" aria-label="Decrease">−1</button>
          <button id="inc" aria-label="Increase">+1</button>
          <button id="reset" class="secondary" aria-label="Reset">Reset</button>
        </div>

        <div style="display:flex; gap:8px; align-items:center; flex-wrap:wrap;">
          <input id="goalInput" type="number" min="1" placeholder="Goal (e.g., 21)" aria-label="Goal" />
          <button id="setGoal" class="secondary">Set Goal</button>
        </div>
      </div>

      <div style="display:flex; justify-content:space-between; margin-top:12px; gap:12px; align-items:center;">
        <div style="display:flex; gap:8px; align-items:center;">
          <input id="perRound" type="number" min="1" placeholder="Per round (e.g., 21)" aria-label="Per round" style="width:150px"/>
          <label style="display:flex;align-items:center;gap:8px;">
            <input id="linkPerRound" type="checkbox" checked /> Per-round = Goal
          </label>
        </div>
        <div>
          <button id="clearHistoryTop" class="secondary">Clear History</button>
        </div>
      </div>

      <div style="margin-top:12px">
        <progress id="progress" max="100" value="0" aria-label="Progress"></progress>
      </div>

      <div style="display:flex; gap:8px; align-items:center; margin-top:12px; flex-wrap:wrap;">
        <input id="addBy" type="number" placeholder="+ Add" style="width:120px" />
        <button id="addBtn" class="secondary">Add</button>
        <button id="undo" class="secondary">Undo</button>

        <label class="small" style="display:flex; gap:8px; align-items:center;">
          <input id="soundToggle" type="checkbox" checked /> Om sound
        </label>
        <label class="small" style="display:flex; gap:8px; align-items:center;">
          <input id="hapticToggle" type="checkbox" checked /> Haptic
        </label>
      </div>

      <div style="margin-top:12px; display:flex; gap:12px; align-items:center; flex-wrap:wrap;">
        <div class="pill">Rounds completed: <span id="roundsCompleted">0</span></div>
        <div class="pill">In-round: <span id="inRound">0</span>/<span id="perRoundDisplay">0</span></div>
      </div>

      <div id="vibeNotice" class="notice"></div>
      <div id="iconNotice" class="notice" style="display:none;"></div>

      <section class="history" id="history" aria-label="History"></section>
    </main>
  </div>

  <div id="roundOverlay" aria-hidden="true"></div>

  <div class="tap-wrap">
    <div id="tap" class="tap-btn" role="button" aria-label="+1 (tap)">
      <div style="display:flex; gap:12px; align-items:center;">
        <div style="color:var(--accent); font-weight:800">Tap</div>
        <div class="tap-count" id="tapCount">+1</div>
      </div>
      <div style="text-align:right;">
        <div class="tap-note">tap</div>
      </div>
    </div>
  </div>

  <script>
  /* -------------------------
     Full app script
     - dynamic per-round linked to goal
     - single-tap increment
     - sound + haptic
     - round-complete overlay (21 s) + long Om (6 s)
     - PWA registration & icon check
     ------------------------- */

  const $ = id => document.getElementById(id);

  // DOM refs
  const countEl = $('count'), inRoundEl = $('inRound'), roundsEl = $('roundsCompleted'),
        perRoundInput = $('perRound'), perRoundDisplay = $('perRoundDisplay'),
        goalText = $('goalText'), historyEl = $('history'), progressEl = $('progress'),
        tapBtn = $('tap'), incBtn = $('inc'), decBtn = $('dec'), resetBtn = $('reset'),
        addBy = $('addBy'), addBtn = $('addBtn'), undoBtn = $('undo'),
        setGoalBtn = $('setGoal'), goalInput = $('goalInput'), linkPerRound = $('linkPerRound'),
        clearHistoryTop = $('clearHistoryTop'), soundToggle = $('soundToggle'), hapticToggle = $('hapticToggle'),
        vibeNotice = $('vibeNotice'), iconNotice = $('iconNotice'), roundOverlay = $('roundOverlay');

  const STORAGE_KEY = 'chant_counter_final_v1';
  const defaultState = {
    totalCount:0, inRound:0, perRound:0, roundsCompleted:0, goal:null, history:[], lastAction:null,
    autoRound:true, sound:true, haptic:true, sessionStart:Date.now()
  };
  let state = {...defaultState};

  // Audio context
  const AudioCtx = (window.AudioContext || window.webkitAudioContext) ? new (window.AudioContext || window.webkitAudioContext)() : null;

  // Short chime (used as fallback or immediate small chime)
  function playRoundChime(){
    if(!AudioCtx) return;
    const now = AudioCtx.currentTime;
    const osc = AudioCtx.createOscillator();
    const gain = AudioCtx.createGain();
    osc.type = 'triangle';
    osc.frequency.setValueAtTime(660, now);
    osc.frequency.exponentialRampToValueAtTime(220, now + 0.45);
    gain.gain.setValueAtTime(0.0001, now);
    gain.gain.exponentialRampToValueAtTime(0.28, now + 0.02);
    gain.gain.exponentialRampToValueAtTime(0.0001, now + 0.8);
    osc.connect(gain); gain.connect(AudioCtx.destination);
    osc.start(now); osc.stop(now + 0.9);
  }

  // --- Long Om + overlay (the block you asked about) ---
  let __longOmStop = null;
  function playLongOm(seconds = 6) {
    if (!AudioCtx) return;
    if (typeof __longOmStop === 'function') {
      try { __longOmStop(); } catch(e) {}
      __longOmStop = null;
    }

    const now = AudioCtx.currentTime;
    const duration = Math.max(0.5, seconds);

    const osc1 = AudioCtx.createOscillator();
    const osc2 = AudioCtx.createOscillator();
    const gain = AudioCtx.createGain();
    const biquad = AudioCtx.createBiquadFilter();

    osc1.type = 'sine';
    osc1.frequency.setValueAtTime(110, now);
    osc2.type = 'sine';
    osc2.frequency.setValueAtTime(220, now);

    biquad.type = 'lowpass';
    biquad.frequency.setValueAtTime(1200, now);
    biquad.Q.setValueAtTime(0.7, now);

    gain.gain.setValueAtTime(0.0001, now);
    gain.gain.linearRampToValueAtTime(0.18, now + 0.25);
    gain.gain.setValueAtTime(0.18, now + duration - 0.8);
    gain.gain.exponentialRampToValueAtTime(0.0001, now + duration);

    osc1.connect(biquad);
    osc2.connect(biquad);
    biquad.connect(gain);
    gain.connect(AudioCtx.destination);

    osc2.detune.value = 8 * (Math.random() - 0.5);

    osc1.start(now);
    osc2.start(now);
    osc1.stop(now + duration + 0.05);
    osc2.stop(now + duration + 0.05);

    __longOmStop = () => {
      try { osc1.stop(); osc2.stop(); } catch(e){}
      try { gain.gain.exponentialRampToValueAtTime(0.0001, AudioCtx.currentTime + 0.05); } catch(e){}
      __longOmStop = null;
    };

    setTimeout(()=> { __longOmStop = null; }, (duration + 0.25) * 1000);
  }

  function createConfettiBurst(n){
    for(let i=0;i<n;i++){
      const p = document.createElement('div');
      p.style.position='fixed';
      p.style.left = (50 + (Math.random()*60 - 30)) + '%';
      p.style.top = (50 + (Math.random()*10 - 5)) + '%';
      p.style.width = p.style.height = (6 + Math.random()*8) + 'px';
      p.style.background = ['#ffd6e8','#ff9acb','#ffbfdc','#ffc1e3'][Math.floor(Math.random()*4)];
      p.style.borderRadius = '3px';
      p.style.zIndex = 1210;
      p.style.opacity = '1';
      document.body.appendChild(p);
      const dx = (Math.random()*160 - 80);
      const dy = -80 - Math.random()*160;
      p.animate([
        { transform: 'translate(0,0) rotate(0deg)', opacity:1 },
        { transform: `translate(${dx}px, ${dy}px) rotate(${Math.random()*360}deg)`, opacity:0 }
      ], { duration: 1000 + Math.random()*400, easing: 'cubic-bezier(.2,.8,.2,1)'});
      setTimeout(()=> p.remove(), 1400);
    }
  }

function showRoundCompleteAnimation() {
  const plusEl = document.getElementById('roundPlus');
  if (plusEl) plusEl.textContent = `+${state.perRound || 0}`;

  // Update overlay content
  roundOverlay.innerHTML = `
    <div style="font-size:22px;font-weight:800;margin-bottom:8px;">Round complete</div>
    <div style="font-size:52px;font-weight:900">ॐ · ${state.perRound || 0}</div>
  `;

  // Make visible with animation
  roundOverlay.style.display = 'block';
  roundOverlay.style.opacity = '0';
  roundOverlay.style.transform = 'translate(-50%,-50%) scale(0.92)';

  roundOverlay.animate([
    { opacity: 0, transform: 'translate(-50%,-50%) scale(0.92)' },
    { opacity: 1, transform: 'translate(-50%,-50%) scale(1.04)' },
    { opacity: 1, transform: 'translate(-50%,-50%) scale(1)' }
  ], { duration: 500, easing: 'cubic-bezier(.2,.9,.3,1)' });

  // Confetti
  createConfettiBurst(15);

  // If already showing, reset its timeout
  if (roundOverlay.__hideTimeout) {
    clearTimeout(roundOverlay.__hideTimeout);
  }

  // Keep visible for full 21 seconds before fading out
  roundOverlay.__hideTimeout = setTimeout(() => {
    roundOverlay.animate([
      { opacity: 1, transform: 'translate(-50%,-50%) scale(1)' },
      { opacity: 0, transform: 'translate(-50%,-50%) scale(0.94)' }
    ], { duration: 700, easing: 'ease' });

    setTimeout(() => { roundOverlay.style.display = 'none'; }, 800);
    roundOverlay.__hideTimeout = null;
  }, 21000); // 21 seconds (21,000 ms)
}

  // immediate short chime + vibration fallback, then long Om + animation
  function handleRoundComplete(){
    if (state.haptic && vibrationSupported) {
      try { navigator.vibrate([60,40,60]); } catch(e){}
    } else {
      if (state.sound && AudioCtx) {
        if (AudioCtx.state === 'suspended') AudioCtx.resume();
        playRoundChime();
      }
    }

    showRoundCompleteAnimation();

    if (state.sound && AudioCtx) {
      if (AudioCtx.state === 'suspended') AudioCtx.resume();
      playLongOm(6); // 6 seconds long Om
    }
  }

  // persistence
  function save(){ localStorage.setItem(STORAGE_KEY, JSON.stringify(state)); }
  function load(){ try{ const s = JSON.parse(localStorage.getItem(STORAGE_KEY)); if(s) state = {...defaultState, ...s}; }catch(e){} }

  // UI render
  function render(){
    countEl.textContent = state.totalCount;
    inRoundEl.textContent = state.inRound;
    perRoundDisplay.textContent = state.perRound || 0;
    roundsEl.textContent = state.roundsCompleted;
    progressEl.value = state.goal ? Math.min(100, Math.round((state.totalCount/state.goal)*100)) : (state.perRound ? Math.min(100, Math.floor((state.inRound/state.perRound)*100)) : 0);
    goalText.textContent = state.goal ? `Goal: ${state.goal} · ${state.totalCount}/${state.goal} (${Math.min(100, Math.round((state.totalCount/state.goal)*100))}%)` : 'Goal: —';
    soundToggle.checked = state.sound; hapticToggle.checked = state.haptic;
    perRoundInput.value = state.perRound || '';
    renderHistory();
    updateVibeNotice();
    save();
  }

  function renderHistory(){
    historyEl.innerHTML = '';
    if(state.history.length === 0){ historyEl.innerHTML = '<div class="small">No history yet</div>'; return; }
    state.history.slice().reverse().forEach(it=>{
      const d = new Date(it.t);
      const div = document.createElement('div');
      div.className = 'hist-item';
      div.style.display = 'flex';
      div.style.justifyContent = 'space-between';
      div.innerHTML = `<div style="color:var(--text)">${it.delta>0?'+':''}${it.delta} → total ${it.totalCount} · in-round ${it.inRound}</div><div class="small">${d.toLocaleString()}</div>`;
      historyEl.appendChild(div);
    });
  }

  // vibration support
  const vibrationSupported = 'vibrate' in navigator;

  function updateVibeNotice(){
    if(!vibrationSupported) vibeNotice.textContent = 'Note: vibration unavailable in this browser (iOS Safari often does not support it). Sound fallback will be used.';
    else vibeNotice.textContent = '';
  }

  // core applyDelta
  function applyDelta(delta, record=true){
    const prevRounds = state.roundsCompleted;
    state.totalCount = (state.totalCount || 0) + delta;
    if(state.totalCount < 0) state.totalCount = 0;

    if(linkPerRound.checked){
      state.perRound = state.goal || 0;
    } else {
      state.perRound = parseInt(perRoundInput.value) || state.perRound || 0;
    }

    if(state.perRound > 0){
      state.inRound = (state.inRound || 0) + delta;
      if(state.inRound < 0){
        if(state.roundsCompleted > 0){
          state.roundsCompleted = Math.max(0, state.roundsCompleted - 1);
          state.inRound = state.perRound + state.inRound;
        } else {
          state.inRound = 0;
        }
      }
      while(state.inRound >= state.perRound){
        state.inRound -= state.perRound;
        state.roundsCompleted += 1;
      }
    } else {
      state.inRound = state.totalCount;
      state.roundsCompleted = 0;
    }

    if(record){
      const entry = { t: Date.now(), delta, totalCount: state.totalCount, inRound: state.inRound };
      state.history.push(entry);
      state.lastAction = entry;
    }

    // feedback per tap
    if(state.haptic && vibrationSupported){
      try{ navigator.vibrate(30); } catch(e){ if(state.sound && AudioCtx){ if(AudioCtx.state==='suspended') AudioCtx.resume(); playRoundChime(); } }
    } else {
      if(state.sound && AudioCtx){ if(AudioCtx.state === 'suspended') AudioCtx.resume(); playRoundChime(); }
    }

    const newRound = state.roundsCompleted > prevRounds;
    render();
    if(newRound) handleRoundComplete();
    return newRound;
  }

  function undo(){
    if(!state.lastAction) return;
    for(let i=state.history.length-1;i>=0;i--){
      if(state.history[i].t === state.lastAction.t){ state.history.splice(i,1); break; }
    }
    const last = state.history[state.history.length-1];
    if(last){
      state.totalCount = last.totalCount;
      state.inRound = last.inRound;
      state.roundsCompleted = Math.floor(state.totalCount / state.perRound);
    } else {
      state.totalCount = 0; state.inRound = 0; state.roundsCompleted = 0;
    }
    state.lastAction = null;
    render();
  }

  // events (single tap only)
  incBtn.addEventListener('click', ()=> applyDelta(1));
  decBtn.addEventListener('click', ()=> applyDelta(-1));
  resetBtn.addEventListener('click', ()=> { if(confirm('Reset total and in-round counts?')){ state.totalCount=0; state.inRound=0; state.roundsCompleted=0; state.history.push({t:Date.now(), delta:0, totalCount:0, inRound:0, note:'reset'}); render(); }});
  addBtn.addEventListener('click', ()=> { const n = parseInt(addBy.value); if(!isNaN(n) && n!==0){ applyDelta(n); addBy.value=''; }});
  undoBtn.addEventListener('click', undo);
  setGoalBtn.addEventListener('click', ()=> { const g = parseInt(goalInput.value); if(!g || g<=0){ state.goal=null; alert('Enter valid goal > 0 or clear'); return; } state.goal = g; if(linkPerRound.checked) state.perRound = g; render(); });
  clearHistoryTop.addEventListener('click', ()=> { if(confirm('Clear history?')){ state.history=[]; render(); }});
  soundToggle.addEventListener('change', e => { state.sound = e.target.checked; save(); });
  hapticToggle.addEventListener('change', e => { state.haptic = e.target.checked; save(); });

  perRoundInput.addEventListener('change', ()=> {
    const v = parseInt(perRoundInput.value);
    if(!linkPerRound.checked && v && v>0){
      state.perRound = v;
      state.roundsCompleted = Math.floor(state.totalCount/state.perRound);
      state.inRound = state.totalCount % state.perRound;
      render();
    }
  });

  linkPerRound.addEventListener('change', ()=> {
    if(linkPerRound.checked){
      state.perRound = state.goal || 0;
      perRoundInput.disabled = true;
    } else {
      perRoundInput.disabled = false;
    }
    render();
  });

  // Tap: single tap increments
  tapBtn.addEventListener('click', ()=> applyDelta(1));

  // keyboard
  window.addEventListener('keydown', (e) => {
    if(e.code === 'Space'){ e.preventDefault(); applyDelta(1); }
    if(e.code === 'Backspace'){ e.preventDefault(); applyDelta(-1); }
  });

  // audio resume on gesture
  ['click','touchstart','keydown'].forEach(evt => {
    window.addEventListener(evt, function resume(){
      if(AudioCtx && AudioCtx.state === 'suspended') AudioCtx.resume();
      window.removeEventListener(evt, resume);
    });
  });

  // icon check helper
  async function checkIcons(){
    try{
      const r1 = await fetch('./icons/icon-192.png', { method: 'HEAD' });
      const r2 = await fetch('./icons/icon-512.png', { method: 'HEAD' });
      if(r1.ok && r2.ok){
        iconNotice.style.display = 'none';
        return true;
      } else {
        iconNotice.style.display = 'block';
        iconNotice.innerText = 'App icons not found: upload ./icons/icon-192.png and ./icons/icon-512.png for proper home-screen icons. (SVG fallbacks exist but PNGs recommended.)';
        return false;
      }
    } catch(e){
      iconNotice.style.display = 'block';
      iconNotice.innerText = 'Could not check icons (network). Ensure ./icons/icon-192.png and ./icons/icon-512.png are present in repo.';
      return false;
    }
  }

  // load + init
  load();
  if(!state.sessionStart) state.sessionStart = Date.now();
  if(linkPerRound.checked){ perRoundInput.disabled = true; if(state.goal) state.perRound = state.goal; }
  render();
  checkIcons();

  // register service worker (for PWA/offline)
  if('serviceWorker' in navigator){
    navigator.serviceWorker.register('./service-worker.js').then(reg => console.log('SW registered', reg)).catch(err => console.warn('SW registration failed', err));
  }
  </script>
</body>
</html>